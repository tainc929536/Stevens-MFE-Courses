---
output: pdf_document

---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```



# FE621.  Assignment #4.


## `r format(Sys.time(), "%Y-%m-%d")`

Name: Tai Nguyen Cong

CWID: 10442353


# Question 3

## Question 3.1
## \textcolor{red}{Solution:}

```{r}
# Download Data
library(quantmod)
amzn.2011 <- getSymbols(Symbols = "AMZN", from = "2011-01-01", to = "2011-12-31", 
                        auto.assign = F, src = "yahoo")
amzn.2011  <- data.frame(amzn.2011)
amzn.2012 <- getSymbols(Symbols = "AMZN", from = "2012-01-01", to = "2012-12-31", 
                        auto.assign = F, src = "yahoo")
amzn.2012  <- data.frame(amzn.2012)
amzn.2013 <- getSymbols(Symbols = "AMZN", from = "2013-01-01", to = "2013-12-31", 
                        auto.assign = F, src = "yahoo")
amzn.2013  <- data.frame(amzn.2013)

# Computing log return
# 2011
amzn.2011.pt <- amzn.2011$AMZN.Adjusted[2:length(amzn.2011$AMZN.Adjusted)]
amzn.2011.pt1 <- amzn.2011$AMZN.Adjusted[1: (length(amzn.2011$AMZN.Adjusted)-1)]
amzn.2011.log.return <- log(amzn.2011.pt) - log(amzn.2011.pt1)

#2012
amzn.2012.pt <- amzn.2012$AMZN.Adjusted[2:length(amzn.2012$AMZN.Adjusted)]
amzn.2012.pt1 <- amzn.2012$AMZN.Adjusted[1: (length(amzn.2012$AMZN.Adjusted)-1)]
amzn.2012.log.return <- log(amzn.2012.pt) - log(amzn.2012.pt1)

#2013
amzn.2013.pt <- amzn.2013$AMZN.Adjusted[2:length(amzn.2013$AMZN.Adjusted)]
amzn.2013.pt1 <- amzn.2013$AMZN.Adjusted[1: (length(amzn.2013$AMZN.Adjusted)-1)]
amzn.2013.log.return <- log(amzn.2013.pt) - log(amzn.2013.pt1)
```


## Question 3.2
## \textcolor{red}{Solution:}

```{r}
# Calculating DFT Time Series
dft.amzn.2011 = fft(amzn.2011.log.return, inverse = F)/sqrt(length(amzn.2011.log.return))
dft.amzn.2012 = fft(amzn.2012.log.return, inverse = F)/sqrt(length(amzn.2012.log.return))
dft.amzn.2013 = fft(amzn.2013.log.return, inverse = F)/sqrt(length(amzn.2013.log.return))

plot(Re(dft.amzn.2011), type = "l", col = "red", main = "Real Parts of DFT", 
     ylab = "Values")
lines(Re(dft.amzn.2012), type = "l", col = "blue")
lines(Re(dft.amzn.2013), type = "l", col = "green")
legend(x = "bottomleft", legend = c("2011", "2012", "2013"), 
       col = c("red", "blue", "green"), lty = rep(1, 3))

plot(Im(dft.amzn.2011), type = "l", col = "red", main = "Imaginary Parts of DFT", 
     ylab = "Values")
lines(Im(dft.amzn.2012), type = "l", col = "blue")
lines(Im(dft.amzn.2013), type = "l", col = "green")
legend(x = "bottomleft", legend = c("2011", "2012", "2013"), 
       col = c("red", "blue", "green"), lty = rep(1, 3))
```
Both real and imaginary part all seems to fluctuate around 0, with some finite variance, for all 3 years of data, which may imply that the time series in 3 years are stationary.

## Question 3.3
## \textcolor{red}{Solution:}

```{r}
x.dft.amzn.2011 <- seq(from =  0, by = 1/(length(amzn.2011.log.return)), length.out = 
      length((Im(dft.amzn.2011))^2))

plot(x.dft.amzn.2011[-1],(Im(dft.amzn.2011[-1]))^2, type="l", 
     xlab = "Frequency", ylab = "Values", main = "Spectra of AMZN Log Return 2011")

x.dft.amzn.2012 <- seq(from =  0, by = 1/(length(amzn.2012.log.return)), length.out = 
                         length((Im(dft.amzn.2012))^2))

plot(x.dft.amzn.2012[-1],(Im(dft.amzn.2012[-1]))^2, type="l", 
     xlab = "Frequency", ylab = "Values", main = "Spectra of AMZN Log Return 2012")

x.dft.amzn.2013 <- seq(from =  0, by = 1/(length(amzn.2013.log.return)), length.out = 
                         length((Im(dft.amzn.2013))^2))

plot(x.dft.amzn.2013[-1],(Im(dft.amzn.2013[-1]))^2, type="l", 
     xlab = "Frequency", ylab = "Values", main = "Spectra of AMZN Log Return 2013")
#http://web.stanford.edu/class/earthsys214/notes/series.html#spectral-analysis
```
We can see clearly that for all 3 dataset of 3 years, the spectra of time series of AMZN do not have the property as of the random walk.


## Question 3.4
## \textcolor{red}{Solution:}

2011
```{r}
#10
dft.amzn.2011.10.terms <- vector("list", 10)
for(i in 1:10) {
  dft.amzn.2011.10.terms[[i]] = dft.amzn.2011[i]*sin((i-1)*pi*x.dft.amzn.2011)
}

pred.10.amzn.2011 <- vector("list", length = length(dft.amzn.2011))
for(i in 1:length(dft.amzn.2011)) {
  for(j in 1:10) {
    pred.10.amzn.2011[[i]][j] = dft.amzn.2011.10.terms[[j]][i]
  }
}

sum.pred.10.amzn.2011 <- c()
for(i in 1:length(dft.amzn.2011)) {
  sum.pred.10.amzn.2011[i] = sum(pred.10.amzn.2011[[i]])/sqrt(length(amzn.2011.log.return))
}

#20
dft.amzn.2011.20.terms <- vector("list", 20)
for(i in 1:20) {
  dft.amzn.2011.20.terms[[i]] = dft.amzn.2011[i]*sin((i-1)*pi*x.dft.amzn.2011)
}

pred.20.amzn.2011 <- vector("list", length = length(dft.amzn.2011))
for(i in 1:length(dft.amzn.2011)) {
  for(j in 1:20) {
    pred.20.amzn.2011[[i]][j] = dft.amzn.2011.20.terms[[j]][i]
  }
}

sum.pred.20.amzn.2011 <- c()
for(i in 1:length(dft.amzn.2011)) {
  sum.pred.20.amzn.2011[i] = sum(pred.20.amzn.2011[[i]])/sqrt(length(amzn.2011.log.return))
}

#40
dft.amzn.2011.40.terms <- vector("list", 40)
for(i in 1:40) {
  dft.amzn.2011.40.terms[[i]] = dft.amzn.2011[i]*sin((i-1)*pi*x.dft.amzn.2011)
}

pred.40.amzn.2011 <- vector("list", length = length(dft.amzn.2011))
for(i in 1:length(dft.amzn.2011)) {
  for(j in 1:40) {
    pred.40.amzn.2011[[i]][j] = dft.amzn.2011.40.terms[[j]][i]
  }
}

sum.pred.40.amzn.2011 <- c()
for(i in 1:length(dft.amzn.2011)) {
  sum.pred.40.amzn.2011[i] = sum(pred.40.amzn.2011[[i]])/sqrt(length(amzn.2011.log.return))
}

#100
dft.amzn.2011.100.terms <- vector("list", 100)
for(i in 1:100) {
  dft.amzn.2011.100.terms[[i]] = dft.amzn.2011[i]*sin((i-1)*pi*x.dft.amzn.2011)
}

pred.100.amzn.2011 <- vector("list", length = length(dft.amzn.2011))
for(i in 1:length(dft.amzn.2011)) {
  for(j in 1:100) {
    pred.100.amzn.2011[[i]][j] = dft.amzn.2011.100.terms[[j]][i]
  }
}

sum.pred.100.amzn.2011 <- c()
for(i in 1:length(dft.amzn.2011)) {
  sum.pred.100.amzn.2011[i] = sum(pred.100.amzn.2011[[i]])/sqrt(length(amzn.2011.log.return))
}

plot(amzn.2011.log.return, type = "l", xlab = "Time", ylab = "Values", 
     main = "Using DFT with Different Numbers of Terms of 2011")
lines(Re(sum.pred.10.amzn.2011), type = "l", col = "blue")
lines(Re(sum.pred.20.amzn.2011), type = "l", col = "orange")
lines(Re(sum.pred.40.amzn.2011), type = "l", col = "brown")
lines(Re(sum.pred.100.amzn.2011), type = "l", col = "red")
legend(x = "bottomleft", legend = c("Original Data", "10 Terms", "20 Terms", "40 Terms", "100 Terms"), 
       col = c("black", "blue", "orange", "brown", "red"), lty = rep(1, 5))

# Spectral Analysis of Time Series
# https://newonlinecourses.science.psu.edu/stat510/lesson/12/12.1
```


2012
```{r}
#10
dft.amzn.2012.10.terms <- vector("list", 10)
for(i in 1:10) {
  dft.amzn.2012.10.terms[[i]] = dft.amzn.2012[i]*sin((i-1)*pi*x.dft.amzn.2012)
}

pred.10.amzn.2012 <- vector("list", length = length(dft.amzn.2012))
for(i in 1:length(dft.amzn.2012)) {
  for(j in 1:10) {
    pred.10.amzn.2012[[i]][j] = dft.amzn.2012.10.terms[[j]][i]
  }
}

sum.pred.10.amzn.2012 <- c()
for(i in 1:length(dft.amzn.2012)) {
  sum.pred.10.amzn.2012[i] = sum(pred.10.amzn.2012[[i]])/sqrt(length(amzn.2012.log.return))
}

#20
dft.amzn.2012.20.terms <- vector("list", 20)
for(i in 1:20) {
  dft.amzn.2012.20.terms[[i]] = dft.amzn.2012[i]*sin((i-1)*pi*x.dft.amzn.2012)
}

pred.20.amzn.2012 <- vector("list", length = length(dft.amzn.2012))
for(i in 1:length(dft.amzn.2012)) {
  for(j in 1:20) {
    pred.20.amzn.2012[[i]][j] = dft.amzn.2012.20.terms[[j]][i]
  }
}

sum.pred.20.amzn.2012 <- c()
for(i in 1:length(dft.amzn.2012)) {
  sum.pred.20.amzn.2012[i] = sum(pred.20.amzn.2012[[i]])/sqrt(length(amzn.2012.log.return))
}

#40
dft.amzn.2012.40.terms <- vector("list", 40)
for(i in 1:40) {
  dft.amzn.2012.40.terms[[i]] = dft.amzn.2012[i]*sin((i-1)*pi*x.dft.amzn.2012)
}

pred.40.amzn.2012 <- vector("list", length = length(dft.amzn.2012))
for(i in 1:length(dft.amzn.2012)) {
  for(j in 1:40) {
    pred.40.amzn.2012[[i]][j] = dft.amzn.2012.40.terms[[j]][i]
  }
}

sum.pred.40.amzn.2012 <- c()
for(i in 1:length(dft.amzn.2012)) {
  sum.pred.40.amzn.2012[i] = sum(pred.40.amzn.2012[[i]])/sqrt(length(amzn.2012.log.return))
}

#100
dft.amzn.2012.100.terms <- vector("list", 100)
for(i in 1:100) {
  dft.amzn.2012.100.terms[[i]] = dft.amzn.2012[i]*sin((i-1)*pi*x.dft.amzn.2012)
}

pred.100.amzn.2012 <- vector("list", length = length(dft.amzn.2012))
for(i in 1:length(dft.amzn.2012)) {
  for(j in 1:100) {
    pred.100.amzn.2012[[i]][j] = dft.amzn.2012.100.terms[[j]][i]
  }
}

sum.pred.100.amzn.2012 <- c()
for(i in 1:length(dft.amzn.2012)) {
  sum.pred.100.amzn.2012[i] = sum(pred.100.amzn.2012[[i]])/sqrt(length(amzn.2012.log.return))
}

plot(amzn.2012.log.return, type = "l", xlab = "Time", ylab = "Values", 
     main = "Using DFT with Different Numbers of Terms of 2012")
lines(Re(sum.pred.10.amzn.2012), type = "l", col = "blue")
lines(Re(sum.pred.20.amzn.2012), type = "l", col = "orange")
lines(Re(sum.pred.40.amzn.2012), type = "l", col = "brown")
lines(Re(sum.pred.100.amzn.2012), type = "l", col = "red")
legend(x = "topleft", legend = c("Original Data", "10 Terms", "20 Terms", "40 Terms", "100 Terms"), 
       col = c("black", "blue", "orange", "brown", "red"), lty = rep(1, 5))

```


2013
```{r}
#10
dft.amzn.2013.10.terms <- vector("list", 10)
for(i in 1:10) {
  dft.amzn.2013.10.terms[[i]] = dft.amzn.2013[i]*sin((i-1)*pi*x.dft.amzn.2013)
}

pred.10.amzn.2013 <- vector("list", length = length(dft.amzn.2013))
for(i in 1:length(dft.amzn.2013)) {
  for(j in 1:10) {
    pred.10.amzn.2013[[i]][j] = dft.amzn.2013.10.terms[[j]][i]
  }
}

sum.pred.10.amzn.2013 <- c()
for(i in 1:length(dft.amzn.2013)) {
  sum.pred.10.amzn.2013[i] = sum(pred.10.amzn.2013[[i]])/sqrt(length(amzn.2013.log.return))
}

#20
dft.amzn.2013.20.terms <- vector("list", 20)
for(i in 1:20) {
  dft.amzn.2013.20.terms[[i]] = dft.amzn.2013[i]*sin((i-1)*pi*x.dft.amzn.2013)
}

pred.20.amzn.2013 <- vector("list", length = length(dft.amzn.2013))
for(i in 1:length(dft.amzn.2013)) {
  for(j in 1:20) {
    pred.20.amzn.2013[[i]][j] = dft.amzn.2013.20.terms[[j]][i]
  }
}

sum.pred.20.amzn.2013 <- c()
for(i in 1:length(dft.amzn.2013)) {
  sum.pred.20.amzn.2013[i] = sum(pred.20.amzn.2013[[i]])/sqrt(length(amzn.2013.log.return))
}

#40
dft.amzn.2013.40.terms <- vector("list", 40)
for(i in 1:40) {
  dft.amzn.2013.40.terms[[i]] = dft.amzn.2013[i]*sin((i-1)*pi*x.dft.amzn.2013)
}

pred.40.amzn.2013 <- vector("list", length = length(dft.amzn.2013))
for(i in 1:length(dft.amzn.2013)) {
  for(j in 1:40) {
    pred.40.amzn.2013[[i]][j] = dft.amzn.2013.40.terms[[j]][i]
  }
}

sum.pred.40.amzn.2013 <- c()
for(i in 1:length(dft.amzn.2013)) {
  sum.pred.40.amzn.2013[i] = sum(pred.40.amzn.2013[[i]])/sqrt(length(amzn.2013.log.return))
}

#100
dft.amzn.2013.100.terms <- vector("list", 100)
for(i in 1:100) {
  dft.amzn.2013.100.terms[[i]] = dft.amzn.2013[i]*sin((i-1)*pi*x.dft.amzn.2013)
}

pred.100.amzn.2013 <- vector("list", length = length(dft.amzn.2013))
for(i in 1:length(dft.amzn.2013)) {
  for(j in 1:100) {
    pred.100.amzn.2013[[i]][j] = dft.amzn.2013.100.terms[[j]][i]
  }
}

sum.pred.100.amzn.2013 <- c()
for(i in 1:length(dft.amzn.2013)) {
  sum.pred.100.amzn.2013[i] = sum(pred.100.amzn.2013[[i]])/sqrt(length(amzn.2013.log.return))
}

plot(amzn.2013.log.return, type = "l", xlab = "Time", ylab = "Values", 
     main = "Using DFT with Different Numbers of Terms of 2013")
lines(Re(sum.pred.10.amzn.2013), type = "l", col = "blue")
lines(Re(sum.pred.20.amzn.2013), type = "l", col = "orange")
lines(Re(sum.pred.40.amzn.2013), type = "l", col = "brown")
lines(Re(sum.pred.100.amzn.2013), type = "l", col = "red")
legend(x = "bottomright", legend = c("Original Data", "10 Terms", "20 Terms", "40 Terms", "100 Terms"), 
       col = c("black", "blue", "orange", "brown", "red"), lty = rep(1, 5))
```


## Question 3.5
## \textcolor{red}{Solution:}

By using DFT, we can convert x(k) = $a_k$ + $b_k$i. We got y(k) = $c_k$ + $d_k$i, where i is the imaginary unit. Using the Euclidean norm, we can obtain for 1 data point, the difference is ($a_k$-$c_k$)^2 + ($b_k$-$d_k$)^2. For N data points, we sum all of these elements.
```{r}
err.2011.100 = sum((Re(sum.pred.100.amzn.2011) - Re(amzn.2011.log.return))^2) + 
                     (sum(Im(sum.pred.100.amzn.2011) - Im(amzn.2011.log.return))^2) 
err.2011.40 = sum((Re(sum.pred.40.amzn.2011) - Re(amzn.2011.log.return))^2) + 
                    sum((Im(sum.pred.40.amzn.2011) - Im(amzn.2011.log.return))^2) 
err.2011.20 = sum((Re(sum.pred.20.amzn.2011) - Re(amzn.2011.log.return))^2) + 
                    sum((Im(sum.pred.20.amzn.2011) - Im(amzn.2011.log.return))^2) 
err.2011.10 = sum((Re(sum.pred.10.amzn.2011) - Re(amzn.2011.log.return))^2) + 
                    sum((Im(sum.pred.10.amzn.2011) - Im(amzn.2011.log.return))^2) 

err.2012.100 = sum((Re(sum.pred.100.amzn.2012) - Re(amzn.2012.log.return))^2) + 
                     sum((Im(sum.pred.100.amzn.2012) - Im(amzn.2012.log.return))^2) 
err.2012.40 = sum((Re(sum.pred.40.amzn.2012) - Re(amzn.2012.log.return))^2) + 
                    sum((Im(sum.pred.40.amzn.2012) - Im(amzn.2012.log.return))^2) 
err.2012.20 = sum((Re(sum.pred.20.amzn.2012) - Re(amzn.2012.log.return))^2) + 
                    sum((Im(sum.pred.20.amzn.2012) - Im(amzn.2012.log.return))^2) 
err.2012.10 = sum((Re(sum.pred.10.amzn.2012) - Re(amzn.2012.log.return))^2) + 
                    sum((Im(sum.pred.10.amzn.2012) - Im(amzn.2012.log.return))^2) 

err.2013.100 = sum((Re(sum.pred.100.amzn.2013) - Re(amzn.2013.log.return))^2) + 
                     sum((Im(sum.pred.100.amzn.2013) - Im(amzn.2013.log.return))^2) 
err.2013.40 = sum((Re(sum.pred.40.amzn.2013) - Re(amzn.2013.log.return))^2) + 
                    sum((Im(sum.pred.40.amzn.2013) - Im(amzn.2013.log.return))^2) 
err.2013.20 = sum((Re(sum.pred.20.amzn.2013) - Re(amzn.2013.log.return))^2) + 
                    sum((Im(sum.pred.20.amzn.2013) - Im(amzn.2013.log.return))^2) 
err.2013.10 = sum((Re(sum.pred.10.amzn.2013) - Re(amzn.2013.log.return))^2) + 
                    sum((Im(sum.pred.10.amzn.2013) - Im(amzn.2013.log.return))^2) 

err.2011 = c(err.2011.100, err.2011.40, err.2011.20, err.2011.10)
err.2012 = c(err.2012.100, err.2012.40, err.2012.20, err.2012.10)
err.2013 = c(err.2013.100, err.2013.40, err.2013.20, err.2013.10)

err.mat = matrix(c(err.2011, err.2012, err.2013 ), ncol = 4, byrow = T)
colnames(err.mat) <- c("10 Terms", "20 Terms", "40 Terms", "100 Terms")
rownames(err.mat) <- c("2011", "2012", "2013")
err.mat
```


## Question 3.6
## \textcolor{red}{Solution:}

```{r}
# https://ccrma.stanford.edu/~jos/mdft/Autocorrelation.html
all.amzn <- c(amzn.2011.log.return, amzn.2012.log.return, amzn.2013.log.return)
acf(all.amzn)
fft.all.amzn = fft(all.amzn, inverse = F)
# From the ACF plot, it is most likely that there exist some correlation of lag 14 for the
# AMZN time series data
tau = 14
dft.all.amzn <- fft(all.amzn)
acf.dft.amzn <- c()
for(i in 1:(length(dft.all.amzn)-tau)) {
  acf.dft.amzn[i] = Conj(dft.all.amzn[i])*dft.all.amzn[i+tau]
}
dft.psd.lag.14 = sum(acf.dft.amzn)/length(acf.dft.amzn + 1)
Re(Conj(dft.psd.lag.14)*dft.psd.lag.14)

# Spectral Density
# https://youtu.be/4d6EeRJZLbo?list=PLMrJAkhIeNNR2W2sPWsYxfrxcASrUt_9j&t=1807
psd = Conj(fft.all.amzn)*fft.all.amzn/length(fft.all.amzn)
plot(Re(psd), type = "l", main = "Spectral Density", xlab = "Values")
```



# Question 4

## \textcolor{red}{Solution:}
```{r}
# Black Scholes Formula
PutOptionPricingBS <- function(risk.free, time.to.maturity, strike.price, 
                               spot.price, vol) {
  
  d1 <- (log(spot.price/strike.price) + (risk.free + 0.5 * vol^2) * time.to.maturity) / 
    (vol * sqrt(time.to.maturity))
  
  d2 <- d1 - vol*sqrt(time.to.maturity)
  
  put.option.price <- pnorm(-d2) * strike.price * exp(-risk.free * time.to.maturity) - 
    pnorm(-d1) * spot.price 
  
  return(put.option.price)
}
PutOptionPricingBS(0.06, 1, 100, 100, 0.5)
```

Finite Element Method
```{r}
# Reference:
# https://github.com/vincent27hugh/FEM_Heston_Model/tree/master/1D_BS/European_Call
library(pracma)
# Intial input, with x values are used for exponential to compute stock price
r=0.06; Tm=1; sigma=0.5; K=100; s0=100
N=10; M=10; xmin=-10; xmax=2

# Create Mesh of 10 values in stock price (N=10) and 10 time intervals (M=10)
x = seq(xmin, xmax, length.out = (N+2))
x.adj = x[2:(length(x)-1)]
dx = x[2] - x[1]
q = 2*r/(sigma^2)
tau = seq(0, 0.5*Tm*(sigma^2), length.out = (M+1)) 
dtau=tau[2]-tau[1]

w.mat = matrix(nrow = length(x.adj), ncol = length(tau))
b.mat = w.mat

# Create A matrix and B matrix as in expression (7)
Amat <- function(N, h) {
  Amat = matrix(nrow = N, ncol = N)
  for(i in 2:(N-1)) {
    Amat[i, ] = c(rep(0, i-2), -1, 2, -1, rep(0, N-i-1))
  }
  Amat[1, ] = c(2, -1, rep(0,N-2))
  Amat[N, ] = c(rep(0,N-2), -1, 2)
  Amat = Amat/h
  return(Amat)
}

Bmat <- function(N, h) {
  Bmat = matrix(nrow = N, ncol = N)
  for(i in 2:(N-1)) {
    Bmat[i, ] = c(rep(0, i-2), 1, 4, 1, rep(0, N-i-1))
  }
  Bmat[1, ] = c(4, 1, rep(0,N-2))
  Bmat[N, ] = c(rep(0,N-2), 1, 4)
  Bmat = Bmat*h/6
  return(Bmat)
}

mid1=Bmat(N,dx)+(dtau/2)*Amat(N,dx)
mid1=solve(mid1)
mid2=Bmat(N,dx)-(dtau/2)*Amat(N,dx)

# General Boundary Conditions of Mesh
alpha <- function(t) {
  al = exp(-0.5*xmax+0.25*t)
  return(al)
}

d.alpha <- function(t) {
  d.al = 0.25*alpha(t)
  return(d.al)
}

phi.beta <- function(xv, t) {
  n = length(xv)
  p.b <- c()
  for(i in 1:n) {
    p.b[i] = -alpha(t)*((xv[i]-xmin)/(xmax-xmin)) + alpha(t) 
  }
  return(p.b)
}

# Initial Condition
gamma <- function(xv) {
  n = length(xv)
  g <- c()
  for(i in 1:n) {
    g[i] = max( (exp(-0.5*xv[i]) - exp(0.5*xv[i])), 0)
  }
  return(g)
}

for(i in 1:length(x.adj)) {
  w.mat[i,1] = gamma(x.adj[i]) - phi.beta(x.adj[i], 0)
}

func.beta <- function(xv, t) {
  n = length(xv)
  f.b <- c()
  for(i in 1:n) {
    f.b[i] = dx*( (xv[i] - xmin)*(-d.alpha(t))/(xmax-xmin) + d.alpha(t) )
  }
  return(f.b)
}

for(i in 1:length(tau)) {
  b.mat[ ,i] = func.beta(x.adj, tau[i])
}

# Updating the matrix of w
for(i in 2:length(tau)) {
  w.mat[, i] = mid1%*%( mid2%*%w.mat[, i-1]-(dtau/2)*(b.mat[, i] + b.mat[ ,i-1]) )
}

# Base matrix to compute value of final result
mat.bs = matrix(nrow = length(x), ncol = length(tau))
for(i in 1:length(x)) {
  for(j in 1:length(tau)) {
    mat.bs[i, j] = phi.beta(x[i], tau[j])
  }
}
w.mat.a = rbind(rep(0, length(tau)), w.mat, rep(0, length(tau)))
n.y = w.mat.a + mat.bs

# Matrix of final result n.v
n.v = n.y
tx = -0.5*(q-1)*x
t.tau = -0.25*((q+1)^2)*tau
for(i in 1:length(x)) {
  for(j in 1:length(tau)) {
    n.v[i,j] = (K*exp(tx[i] + t.tau[j]))*n.y[i,j]+1
  }
}

# The column 1 of matrix n.v is the option prices at time 0 with different values of 
# stock price, so 1 use 1 dimensional interpolation to obtain value of put option
s.p = s0*exp(x)
interp1(s.p, n.v[ ,1], 100)
```
The value of put options from 2 models are pretty close, about 16 USD.
