---
output: pdf_document

---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```



# FE621. Final Exam


## `r format(Sys.time(), "%Y-%m-%d")`

Name: Tai Nguyen Cong

CWID: 10442353

# Question 1

## Question 1.1
```{r}
r = 0.05
div = 0.03
sigma = 0.2
s0 = 100
k = 100
t = 1 # Time to maturity
N = 100000 # Number of Simulations
M = 300 # Number of Time steps
b1 = -1 # Beta1
```
For this question, I use 100,000 simulations rather than 1 million, since it would require lots of time for computational

## \textcolor{red}{Solution:} 
```{r}
MC.Option.Pricing <- function(s0, k, t, r, sigma, div, N, M) {
  start.time = proc.time()
  delt = t/M
  nudt = (r - div - 0.5*sigma^2)*delt
  sigsdt = sigma*sqrt(delt)
  ln.s0 = log(s0)
  
  ln.stock.price <- matrix(nrow = N, ncol = M)
  for(i in 1:N) {
    for(j in 2:M) {
      set.seed(i)
      ln.stock.price[i, 1] = ln.s0 + nudt + sigsdt*rnorm(1, 0, 1)
      set.seed(i*j*5)
      ln.stock.price[i, j] = ln.stock.price[i, j-1] + nudt + sigsdt*rnorm(1, 0, 1)
    }
  }
  stock.price = exp(ln.stock.price[, M])
  sim.eu.call.v = pmax((stock.price - k), 0)
  sim.eu.put.v = pmax((k-stock.price), 0)
  
  call.val = mean(sim.eu.call.v)*exp(-r*t)
  put.val = mean(sim.eu.put.v)*exp(-r*t)
  
  sd.call = exp(-2*r*t)*sqrt( sum(sim.eu.call.v^2) - ((sum(sim.eu.call.v))^2)/N )/(N-1)
  se.call = sd.call/sqrt(N)
  
  sd.put = exp(-2*r*t)*sqrt( sum(sim.eu.put.v^2) - ((sum(sim.eu.put.v))^2)/N )/(N-1)
  se.put = sd.put/sqrt(N)
  end.time = proc.time()
  CPU.time = end.time - start.time
  r1 <- c(call.val, sd.call, se.call, CPU.time[3])
  r2 <- c(put.val, sd.put, se.put, CPU.time[3])
  all.data = matrix(c(r1, r2), nrow = 2, byrow = T)
  colnames(all.data) <- c("Option Value", "Standard Deviation", "Standard Error", "CPU Time")
  rownames(all.data) <- c("EU Call Option", "EU Put Option")
  return(all.data)
}

MC1 <- MC.Option.Pricing(s0, k, t, r, sigma, div, N, M)
MC1
```
So the standard error for European Call option using Monte Carlo Simulation is 0.000128 and for European Put option is 0.000089

## Question 1.2
## \textcolor{red}{Solution:}
Antithetic Variate
```{r}
# Antithetic Variate
MC.Antithetic.Option.Pricing <- function(s0, k, t, r, sigma, div, N, M) {
  start.time = proc.time()
  delt = t/M
  nudt = (r - div - 0.5*sigma^2)*delt
  sigsdt = sigma*sqrt(delt)
  ln.s0 = log(s0)
  
  lnst1 <- matrix(nrow = N, ncol = M)
  lnst2 <- matrix(nrow = N, ncol = M)
  for(i in 1:N) {
    for(j in 2:M) {
      set.seed(i)
      lnst1[i, 1] = ln.s0 + nudt + sigsdt*rnorm(1,0,1)
      set.seed(i)
      lnst2[i, 1] = ln.s0 + nudt - sigsdt*rnorm(1,0,1)
      set.seed(i*j*3)
      w = rnorm(1,0,1)
      lnst1[i, j] = lnst1[i, j-1] + nudt + sigsdt*w
      lnst2[i, j] = lnst2[i, j-1] + nudt + sigsdt*(-w)
    }
  }
  st1.price = exp(lnst1[, M])
  st2.price = exp(lnst2[, M])
  av.call = 0.5*(pmax((st1.price - k), 0) + pmax((st2.price - k), 0))
  av.put = 0.5*(pmax((k-st1.price), 0) + pmax((k-st2.price), 0))
  
  call.val = mean(av.call)*exp(-r*t)
  put.val = mean(av.put)*exp(-r*t)
  
  sd.call = exp(-2*r*t)*sqrt( sum(av.call^2) - ((sum(av.call))^2)/N )/(N-1)
  se.call = sd.call/sqrt(N)
  
  sd.put = exp(-2*r*t)*sqrt( sum(av.put^2) - ((sum(av.put))^2)/N )/(N-1)
  se.put = sd.put/sqrt(N)
  
  end.time = proc.time()
  CPU.time = end.time - start.time
  r1 <- c(call.val, sd.call, se.call, CPU.time[3])
  r2 <- c(put.val, sd.put, se.put, CPU.time[3])
  
  all.data = matrix(c(r1, r2), nrow = 2, byrow = T)
  colnames(all.data) <- c("Option Value", "Standard Deviation", "Standard Error", "CPU Time")
  rownames(all.data) <- c("EU Call Option", "EU Put Option")
  return(all.data)
}

MC2 <- MC.Antithetic.Option.Pricing(s0, k, t, r, sigma, div, N, M)
```

Function computing Delta of Options Using Black-Scholes
```{r}
# Delta of Call Option
black.scholes.delta.call <- function(spot.price, strike.price, risk.free, div, time.to.maturity, vol) {
  d1 = (log(spot.price/strike.price) + (risk.free - div + 0.5 * vol^2) * (1-time.to.maturity)) / 
    (vol * sqrt((1-time.to.maturity)))
  delta = pnorm(d1)*exp(-div*(1-time.to.maturity))
  return(delta)
}

# Delta of Put Option
black.scholes.delta.put <- function(spot.price, strike.price, risk.free, div, time.to.maturity, vol) {
  d1 = (log(spot.price/strike.price) + (risk.free - div + 0.5 * vol^2) * (1-time.to.maturity)) / 
    (vol * sqrt((1-time.to.maturity)))
  delta = (pnorm(d1)-1)*exp(-div*(1-time.to.maturity))
  return(delta)
}
```

Delta Base
```{r}
# Delta Base
MC.Delta.Base.Option.Pricing <- function(s0, k, t, r, sigma, div, N, M, b1) {
  start.time = proc.time()
  delt = t/M
  nudt = (r - div - 0.5*sigma^2)*delt
  sigsdt = sigma*sqrt(delt)
  ln.s0 = log(s0)
  erddt = exp((r-div)*delt)
  
  st <- matrix(nrow = N, ncol = M)
  cv.call <- matrix(nrow = N, ncol = M)
  cv.put <- matrix(nrow = N, ncol = M)
  
  for(i in 1:N) {
    for(j in 2:M) {
      set.seed(i)
      st[i,1] = s0*exp(nudt + sigsdt*rnorm(1,0,1))
      set.seed(i*j*4)
      st[i,j] = st[i,j-1]*exp(nudt + sigsdt*rnorm(1,0,1))
      
      cv.call[i,1] = 0 + black.scholes.delta.call(s0, k, r, div, delt, sigma)*
        (st[i,1] - s0*erddt)
      cv.put[i,1] = 0 + black.scholes.delta.put(s0, k, r, div, delt, sigma)*
        (st[i,1] - s0*erddt)
      
      cv.call[i,j] = cv.call[i, j-1] + 
        black.scholes.delta.call(st[i,j-1], k, r, div, j*delt, sigma)*
        (st[i,j] - st[i,j-1]*erddt)
      cv.put[i,j] = cv.put[i, j-1] + 
        black.scholes.delta.put(st[i,j-1], k, r, div, j*delt, sigma)*
        (st[i,j] - st[i,j-1]*erddt)
    }
  }
  
  delta.base.call = pmax((st[, M]-k), 0) + b1*cv.call[, M]
  delta.base.put = pmax((k-st[, M]), 0) + b1*cv.put[, M]
  
  call.val = mean(delta.base.call)*exp(-r*t)
  put.val = mean(delta.base.put)*exp(-r*t)
  
  sd.call = exp(-2*r*t)*sqrt( sum(delta.base.call^2) - ((sum(delta.base.call))^2)/N )/(N-1)
  se.call = sd.call/sqrt(N)
  
  sd.put = exp(-2*r*t)*sqrt( sum(delta.base.put^2) - ((sum(delta.base.put))^2)/N )/(N-1)
  se.put = sd.put/sqrt(N)
  
  end.time = proc.time()
  CPU.time = end.time - start.time
  r1 <- c(call.val, sd.call, se.call, CPU.time[3])
  r2 <- c(put.val, sd.put, se.put, CPU.time[3])
  
  all.data = matrix(c(r1, r2), nrow = 2, byrow = T)
  colnames(all.data) <- c("Option Value", "Standard Deviation", "Standard Error", "CPU Time")
  rownames(all.data) <- c("EU Call Option", "EU Put Option")
  return(all.data)
}

MC3 <- MC.Delta.Base.Option.Pricing(s0, k, t, r, sigma, div, N, M, b1)
```

Antithetic Variate and Delta Base
```{r}
# Antithetic Variate and Delta Base
MC.Antithetic.Delta.Base.Option.Pricing <- function(s0, k, t, r, sigma, div, N, M, b1) {
  start.time = proc.time()
  delt = t/M
  nudt = (r - div - 0.5*sigma^2)*delt
  sigsdt = sigma*sqrt(delt)
  ln.s0 = log(s0)
  erddt = exp((r-div)*delt)
  
  st1.av <- matrix(nrow = N, ncol = M)
  st2.av <- matrix(nrow = N, ncol = M)
  cv.call.av.1 <- matrix(nrow = N, ncol = M)
  cv.call.av.2 <- matrix(nrow = N, ncol = M)
  cv.put.av.1 <- matrix(nrow = N, ncol = M)
  cv.put.av.2 <- matrix(nrow = N, ncol = M)
  
  for(i in 1:N) {
    for(j in 2:M) {
      set.seed(i)
      st1.av[i,1] = s0*exp(nudt + sigsdt*rnorm(1,0,1))
      set.seed(i)
      st2.av[i,1] = s0*exp(nudt - sigsdt*rnorm(1,0,1))
      set.seed(i*j*4)
      st1.av[i,j] = st1.av[i,j-1]*exp(nudt + sigsdt*rnorm(1,0,1))
      set.seed(i*j*4)
      st2.av[i,j] = st2.av[i,j-1]*exp(nudt + sigsdt*(-rnorm(1,0,1)) )
      
      cv.call.av.1[i,1] = 0 + black.scholes.delta.call(s0, k, r, div, delt, sigma)*
        (st1.av[i,1] - s0*erddt)
      cv.call.av.2[i,1] = 0 + black.scholes.delta.call(s0, k, r, div, delt, sigma)*
        (st2.av[i,1] - s0*erddt)
      
      cv.put.av.1[i,1] = 0 + black.scholes.delta.put(s0, k, r, div, delt, sigma)*
        (st1.av[i,1] - s0*erddt)
      cv.put.av.2[i,1] = 0 + black.scholes.delta.put(s0, k, r, div, delt, sigma)*
        (st2.av[i,1] - s0*erddt)
      
      cv.call.av.1[i,j] = cv.call.av.1[i, j-1] + 
        black.scholes.delta.call(st1.av[i,j-1], k, r, div, j*delt, sigma)*
        (st1.av[i,j] - st1.av[i,j-1]*erddt)
      cv.call.av.2[i,j] = cv.call.av.2[i, j-1] + 
        black.scholes.delta.call(st2.av[i,j-1], k, r, div, j*delt, sigma)*
        (st2.av[i,j] - st2.av[i,j-1]*erddt)
      
      cv.put.av.1[i,j] = cv.put.av.1[i, j-1] + 
        black.scholes.delta.put(st1.av[i,j-1], k, r, div, j*delt, sigma)*
        (st1.av[i,j] - st1.av[i,j-1]*erddt)
      cv.put.av.2[i,j] = cv.put.av.2[i, j-1] + 
        black.scholes.delta.put(st2.av[i,j-1], k, r, div, j*delt, sigma)*
        (st2.av[i,j] - st2.av[i,j-1]*erddt)
    }
  }
  av.call.del = 0.5*( (pmax((st1.av[, M] - k), 0) + b1*cv.call.av.1[, M]) + 
                        (pmax((st2.av[, M] - k), 0) + b1*cv.call.av.2[, M]) )
  av.put.del = 0.5*( (pmax((k-st1.av[, M]), 0) + b1*cv.put.av.1[, M]) + 
                       (pmax((k-st2.av[, M]), 0) + b1*cv.put.av.2[, M]) )
  
  call.val = mean(av.call.del)*exp(-r*t)
  put.val = mean(av.put.del)*exp(-r*t)
  
  sd.call = exp(-2*r*t)*sqrt( sum(av.call.del^2) - ((sum(av.call.del))^2)/N )/(N-1)
  se.call = sd.call/sqrt(N)
  
  sd.put = exp(-2*r*t)*sqrt( sum(av.put.del^2) - ((sum(av.put.del))^2)/N )/(N-1)
  se.put = sd.put/sqrt(N)
  
  end.time = proc.time()
  CPU.time = end.time - start.time
  r1 <- c(call.val, sd.call, se.call, CPU.time[3])
  r2 <- c(put.val, sd.put, se.put, CPU.time[3])
  
  all.data = matrix(c(r1, r2), nrow = 2, byrow = T)
  colnames(all.data) <- c("Option Value", "Standard Deviation", "Standard Error", "CPU Time")
  rownames(all.data) <- c("EU Call Option", "EU Put Option")
  return(all.data)
}

MC4 <- MC.Antithetic.Delta.Base.Option.Pricing(s0, k, t, r, sigma, div, N, M, b1)
```

Result of 4 Methods
```{r}
# Call Option
MC.call <- matrix(c(MC1[1,], MC2[1,], MC3[1,], MC4[1,] ), byrow = T, nrow = 4)
rownames(MC.call) <- c("MC Simulation", "Antithetic Variate", "Delta Base", "Antithetic and Delta")
colnames(MC.call) <- c("Option Value", "Standard Deviation", "Standard Error", "CPU Time")
MC.call

# Put Option
MC.put <- matrix(c(MC1[2,], MC2[2,], MC3[2,], MC4[2,] ), byrow = T, nrow = 4)
rownames(MC.put) <- c("MC Simulation", "Antithetic Variate", "Delta Base", "Antithetic and Delta")
colnames(MC.put) <- c("Option Value", "Standard Deviation", "Standard Error", "CPU Time")
MC.put
```
As we can see from the table result, for a quite large number of simulations, the result produced by 4 methods are roughly the same, especially for 3 methods: Antithetic Variate, Delta Base and Antithetic Variate combine with Delta Base. The result produced by these 3 methods may give a more accurate result compares to simple Monte Carlo Simulation of the first method. However, this precision obtained by exchanging in amount of time used for calculation. We can see a great increase in time of computation. Also, as we can see, the more complicate the method, the more time it requires for computation. The Standard deviation also decrease for more complicated methods, compares to simple Monte Carlo simulation.


# Question 2

## Question 2.1
## \textcolor{red}{Solution:}

Using Black Scholes Formula
```{r}
# BS Call Option formula
CallOptionPricingBS <- function(risk.free, time.to.maturity, strike.price, 
                                spot.price, vol, div) {
  start.time = proc.time()
  
  d1 <- (log(spot.price/strike.price) + (risk.free - div + 0.5 * vol^2) * time.to.maturity) / 
    (vol * sqrt(time.to.maturity))
  
  d2 <- d1 - vol*sqrt(time.to.maturity)
  
  call.option.price <- (pnorm(d1) * spot.price * exp((r-div)*time.to.maturity) - pnorm(d2) * 
                          strike.price)*exp(-risk.free * time.to.maturity)
  end.time = proc.time()
  CPU.time = end.time - start.time
  all.data <- matrix(c(call.option.price, CPU.time[3]), nrow = 1)
  colnames(all.data) <- c("Call Value", "CPU Time")
  return(all.data)
}

BS.call <- CallOptionPricingBS(r, t, k, s0, sigma, div)

# BS Put Option formula
PutOptionPricingBS <- function(risk.free, time.to.maturity, strike.price, 
                               spot.price, vol, div) {
  start.time = proc.time()
  
  d1 <- (log(spot.price/strike.price) + (risk.free - div + 0.5 * vol^2) * time.to.maturity) / 
    (vol * sqrt(time.to.maturity))
  
  d2 <- d1 - vol*sqrt(time.to.maturity)
  
  put.option.price <- (pnorm(-d2) * strike.price - pnorm(-d1) * 
                         spot.price * exp((r-div)*time.to.maturity)) *
    exp(-risk.free * time.to.maturity)
  end.time = proc.time()
  CPU.time = end.time - start.time
  all.data <- matrix(c(put.option.price, CPU.time[3]), nrow = 1)
  colnames(all.data) <- c("Put Value", "CPU Time")
  return(all.data)
}

BS.put <- PutOptionPricingBS(r, t, k, s0, sigma, div)
```

Binomial Tree
```{r}
Binomial.EU.Option.Pricing <- function(s0, k, t, r, sigma, div, M) {
  start.time = proc.time()
  delt = t/M
  v = r - div - 0.5*sigma^2
  delu = sqrt(delt*sigma^2 + (delt*v)^2)
  deld = -delu
  pu = 0.5 + 0.5*v*delt/delu
  pd = 1 - pu
  disc = exp(-r*delt)
  
  stock.price.fin <- c()
  call.fin <- c()
  put.fin <- c()
  for(i in 2:(M+1)) {
    stock.price.fin[1] = s0*exp(M*deld)
    stock.price.fin[i] = stock.price.fin[i-1]*exp(delu - deld)
    call.fin[1] = max((stock.price.fin[1] - k), 0)
    put.fin[1] = max((k-stock.price.fin[1]), 0)
    call.fin[i] = max((stock.price.fin[i] - k), 0)
    put.fin[i] = max((k-stock.price.fin[i]), 0)
  }
  
  call.mat <- vector("list", M+1)
  put.mat <- vector("list", M+1)
  call.mat[[1]] = call.fin
  put.mat[[1]] = put.fin
  for(i in 2:(M+1)) {
    for(j in 1:M) {
      call.mat[[i]][j] = disc*(pd*call.mat[[i-1]][j] + pu*call.mat[[i-1]][j+1])
      put.mat[[i]][j] = disc*(pd*put.mat[[i-1]][j] + pu*put.mat[[i-1]][j+1])
    }
    call.mat <- lapply(call.mat, function(x) x[!is.na(x)])
    put.mat <- lapply(put.mat, function(x) x[!is.na(x)])
  }
  end.time = proc.time()
  CPU.time = end.time - start.time
  all.data = matrix(c(call.mat[[M+1]], put.mat[[M+1]], CPU.time[3]), nrow = 1)
  colnames(all.data) <- c("Call Option", "Put Option", "CPU Time")
  return(all.data)
}
Bin.EU <- Binomial.EU.Option.Pricing(s0, k, t, r, sigma, div, M)
```

Trinomial Tree
```{r}
Trinomial.EU.Option.Pricing <- function(s0, k, t, r, sigma, div, M) {
  start.time = proc.time()
  delt = t/M
  nu = r - div - 0.5*sigma^2
  delx = sigma*sqrt(3*delt)
  edx = exp(delx)
  pu = 0.5*( (delt*sigma^2 + (nu*delt)^2)/(delx^2) + nu*delt/delx )
  pm = 1 - (delt*sigma^2 + (nu*delt)^2)/(delx^2)
  pd = 0.5*( (delt*sigma^2 + (nu*delt)^2)/(delx^2) - nu*delt/delx )
  disc = exp(-r*delt)
  
  stock.price.fin <- c()
  call.fin <- c()
  put.fin <- c()
  for(i in 2:(2*M+1)) {
    stock.price.fin[1] = s0*exp(-M*delx)
    stock.price.fin[i] = stock.price.fin[i-1]*edx
    call.fin[1] = max((stock.price.fin[1] - k), 0)
    put.fin[1] = max((k-stock.price.fin[1]), 0)
    call.fin[i] = max((stock.price.fin[i] - k), 0)
    put.fin[i] = max((k-stock.price.fin[i]), 0)
  }
  
  call.mat <- vector("list", 2*M+1)
  put.mat <- vector("list", 2*M+1)
  call.mat[[1]] = call.fin
  put.mat[[1]] = put.fin
  for(i in 2:(2*M+1)) {
    for(j in 2:(2*M)) {
      call.mat[[i]][j] = disc*(pd*call.mat[[i-1]][j-1] + 
                                 pm*call.mat[[i-1]][j] + pu*call.mat[[i-1]][j+1])
      put.mat[[i]][j] = disc*(pd*put.mat[[i-1]][j-1] + 
                                pm*put.mat[[i-1]][j] + pu*put.mat[[i-1]][j+1])
      
    }
    call.mat <- lapply(call.mat, function(x) x[!is.na(x)])
    put.mat <- lapply(put.mat, function(x) x[!is.na(x)])
  }
  end.time = proc.time()
  CPU.time = end.time - start.time
  all.data = matrix(c(call.mat[[ceiling(M+0.5)]], put.mat[[ceiling(M+0.5)]], CPU.time[3]), nrow = 1)
  colnames(all.data) <- c("Call Option", "Put Option", "CPU Time")
  return(all.data)
}
Tri.EU <- Trinomial.EU.Option.Pricing(s0, k, t, r, sigma, div, M)
```

Explicit Finite Difference Method
```{r}
# EU Call
explicitFDM.EC <- function(s0, k, t, r, sig, div, M) {
  start.time = proc.time()
  delt = t/M
  delx = sig*sqrt(3*delt)
  v = r - div - 0.5*sig^2
  
  pu = 0.5*delt*((sig/delx)^2 + v/delx)
  pm = 1 - delt*(sig/delx)^2 -r*delt
  pd = 0.5*delt*((sig/delx)^2 - v/delx)
  
  num = seq(-M, M, 1)
  stock.pr.fin = s0*exp(num*delx)
  
  EC.res = matrix(nrow = M+1, ncol = 2*M+1)
  for(i in 1:length(stock.pr.fin)) {
    EC.res[1, i] = max(c(0, stock.pr.fin[i] - k))
  }
  
  for(i in 2:(M+1)) {
    for(j in 2:(2*M)) {
      EC.res[i, j] = pd*EC.res[i-1, j-1] + pm*EC.res[i-1, j] + pu*EC.res[i-1, j+1]
      EC.res[i, 1] = EC.res[i, 2]
      EC.res[i, 2*M+1] = EC.res[i, 2*M] + stock.pr.fin[length(stock.pr.fin)] - 
        stock.pr.fin[length(stock.pr.fin)-1]
    }
  }
  end.time = proc.time()
  CPU.time = end.time - start.time
  dat = c(EC.res[M+1, ceiling(M+0.5)], CPU.time[3])
  all.data = matrix(c(dat), nrow = 1)
  colnames(all.data) <- c("Call Value", "CPU Time")
  return(all.data)
}

# EU Put
explicitFDM.EP <- function(s0, k, t, r, sig, div, M) {
  start.time = proc.time()
  delt = t/M
  delx = sig*sqrt(3*delt)
  v = r - div - 0.5*sig^2
  
  pu = 0.5*delt*((sig/delx)^2 + v/delx)
  pm = 1 - delt*(sig/delx)^2 -r*delt
  pd = 0.5*delt*((sig/delx)^2 - v/delx)
  
  num = seq(-M, M, 1)
  stock.pr.fin = s0*exp(num*delx)
  
  EP.res = matrix(nrow = M+1, ncol = 2*M+1)
  for(i in 1:length(stock.pr.fin)) {
    EP.res[1, i] = max(c(0, k - stock.pr.fin[i]))
  }
  
  for(i in 2:(M+1)) {
    for(j in 2:(2*M)) {
      EP.res[i, j] = pd*EP.res[i-1, j-1] + pm*EP.res[i-1, j] + pu*EP.res[i-1, j+1]
      EP.res[i, 2*M+1] = EP.res[i, 2*M]
      EP.res[i, 1] = EP.res[i, 2] + stock.pr.fin[2] - stock.pr.fin[1]
    }
  }
  end.time = proc.time()
  CPU.time = end.time - start.time
  all.data = matrix(c(EP.res[M+1, ceiling(M+0.5)], CPU.time[3]), nrow = 1)
  colnames(all.data) <- c("Put Value", "CPU Time")
  return(all.data)
}

EFD.call <- explicitFDM.EC(s0, k, t, r, sigma, div, M)
EFD.put <- explicitFDM.EP(s0, k, t, r, sigma, div, M)
```


## Question 2.2
## \textcolor{red}{Solution:}
Summarizing Result
```{r}
# Call Option
EU.Call.Compare <- matrix(c(MC1[1, c(1,4)], BS.call[1, c(1,2)], Bin.EU[1, c(1,3)], 
                            Tri.EU[1, c(1,3)], EFD.call), ncol = 2, byrow = T)
colnames(EU.Call.Compare) <- c("EU Call Values", "CPU Time")
rownames(EU.Call.Compare) <- c("MC Simulation", "Black-Scholes", "Binomial", "Trinomial", "EFD")
EU.Call.Compare

# Put Option
EU.Put.Compare <- matrix(c(MC1[2, c(1,4)], BS.put[1, c(1,2)], Bin.EU[1, c(2,3)], 
                            Tri.EU[1, c(2,3)], EFD.put), ncol = 2, byrow = T)
colnames(EU.Put.Compare) <- c("EU Put Values", "CPU Time")
rownames(EU.Put.Compare) <- c("MC Simulation", "Black-Scholes", "Binomial", "Trinomial", "EFD")
EU.Put.Compare
```
We can see that all methods give roughly the same result, especially for the 4 methods: Black-Scholes, Binomial Tree, Trnomial Tree and Explicit Finite Different (EFD). All of these 4 methods agree that the European Call Option price is roughly 8.65 USD and for Put Option is about 6.73 USD. Also, in terms of time for calculation, we can clearly see that all 4 methods use shorter amount of time with more accuracy in compuation.


# Question 3

## Question 3.1
## \textcolor{red}{Solution:}
Binomial Tree for American Option
```{r}
Binomial.US.Option.Pricing <- function(s0, k, t, r, sigma, div, M) {
  delt = t/M
  v = r - div - 0.5*sigma^2
  delu = sqrt(delt*sigma^2 + (delt*v)^2)
  deld = -delu
  pu = 0.5 + 0.5*v*delt/delu
  pd = 1 - pu
  disc = exp(-r*delt)
  
  edxud = exp(delu-deld)
  edxd = exp(deld)
  
  stock.price.fin <- c()
  call.fin <- c()
  put.fin <- c()
  for(i in 2:(M+1)) {
    stock.price.fin[1] = s0*exp(M*deld)
    stock.price.fin[i] = stock.price.fin[i-1]*edxud
    call.fin[1] = max((stock.price.fin[1] - k), 0)
    put.fin[1] = max((k-stock.price.fin[1]), 0)
    call.fin[i] = max((stock.price.fin[i] - k), 0)
    put.fin[i] = max((k-stock.price.fin[i]), 0)
  }
  
  stock.price.all <- vector("list", M+1)
  stock.price.all[[1]] <- stock.price.fin
  call.mat <- vector("list", M+1)
  call.mat[[1]] = call.fin
  put.mat <- vector("list", M+1)
  put.mat[[1]] = put.fin
  for(i in 2:(M+1)) {
    for(j in 1:M) {
      stock.price.all[[i]][j] = stock.price.all[[i-1]][j+1]*edxd
      call.mat[[i]][j] = max((stock.price.all[[i]][j]-k), 
                             disc*(pd*call.mat[[i-1]][j] + pu*call.mat[[i-1]][j+1]))
      put.mat[[i]][j] = max((k-stock.price.all[[i]][j]), 
                            disc*(pd*put.mat[[i-1]][j] + pu*put.mat[[i-1]][j+1]))
    }
    stock.price.all <- lapply(stock.price.all, function(x) x[!is.na(x)])
    call.mat <- lapply(call.mat, function(x) x[!is.na(x)])
    put.mat <- lapply(put.mat, function(x) x[!is.na(x)])
  }
  all.data = matrix(c(call.mat[[M+1]], put.mat[[M+1]]), nrow = 1)
  colnames(all.data) <- c("Call Option", "Put Option")
  return(all.data)
}
Bin.US <- Binomial.US.Option.Pricing(s0, k, t, r, sigma, div, M)
```

Trinomial Tree for American Option
```{r}
Trinomial.US.Option.Pricing <- function(s0, k, t, r, sigma, div, M) {
  delt = t/M
  nu = r - div - 0.5*sigma^2
  delx = sigma*sqrt(3*delt)
  edx = exp(delx)
  pu = 0.5*( (delt*sigma^2 + (nu*delt)^2)/(delx^2) + nu*delt/delx )
  pm = 1 - (delt*sigma^2 + (nu*delt)^2)/(delx^2)
  pd = 0.5*( (delt*sigma^2 + (nu*delt)^2)/(delx^2) - nu*delt/delx )
  disc = exp(-r*delt)
  
  stock.price.fin <- c()
  call.fin <- c()
  put.fin <- c()
  for(i in 2:(2*M+1)) {
    stock.price.fin[1] = s0*exp(-M*delx)
    stock.price.fin[i] = stock.price.fin[i-1]*edx
    call.fin[1] = max((stock.price.fin[1] - k), 0)
    put.fin[1] = max((k-stock.price.fin[1]), 0)
    call.fin[i] = max((stock.price.fin[i] - k), 0)
    put.fin[i] = max((k-stock.price.fin[i]), 0)
  }
  
  stock.price.all <- vector("list", M+1)
  stock.price.all[[1]] <- stock.price.fin
  call.mat <- vector("list", M+1)
  call.mat[[1]] = call.fin
  put.mat <- vector("list", M+1)
  put.mat[[1]] = put.fin
  rep.step <- seq(2*M, 2, -2)
  for(i in 2:(M+1)) {
    stock.price.all[[i]] = stock.price.all[[i-1]][-c(1, length(stock.price.all[[i-1]]))]
    for(j in 2:rep.step[i-1]) {
      call.mat[[i]][j] = max( (stock.price.all[[i]][j-1]-k),
                            disc*(pd*call.mat[[i-1]][j-1] + pm*call.mat[[i-1]][j] + pu*call.mat[[i-1]][j+1]))
      put.mat[[i]][j] = max( (k-stock.price.all[[i]][j-1]),
                            disc*(pd*put.mat[[i-1]][j-1] + pm*put.mat[[i-1]][j] + pu*put.mat[[i-1]][j+1]))
      call.mat <- lapply(call.mat, function(x) x[!is.na(x)])
      put.mat <- lapply(put.mat, function(x) x[!is.na(x)])
    }
  }
  all.data = matrix(c(call.mat[[M+1]], put.mat[[M+1]]), nrow = 1)
  colnames(all.data) <- c("Call Option", "Put Option")
  return(all.data)
}
Tri.US <- Trinomial.US.Option.Pricing(s0, k, t, r, sigma, div, M)
```

## Question 3.2
## \textcolor{red}{Solution:}
```{r}
US.call <- c(Bin.US[1,1], Tri.US[1,1], BS.call[1,1])
US.put <- c(Bin.US[1,2], Tri.US[1,2], BS.put[1,1])
US.compare <- matrix(c(US.call, US.put), nrow = 2, byrow = T)
rownames(US.compare) <- c("US Call Option", "US Put Option")
colnames(US.compare) <- c("Binomial", "Trinomial", "Black-Scholes")
US.compare
```
We can see that The Value for American Call Option computed by Binomial and Trinomial Tree are almost identical to the value from Black-Scholes Formula. This is in conformity with theory as it is never optimal to exercise early for American Call Options, so the value for European and American Call option for the same asset should be the same. However, we can clearly see the difference for Put option, since we can maximize our profit for early excercising American Put option, hence it should have a higher price, compares to European Put Option of the same asset. Here, we have the value for American Put Option produced by Binomial and Trinomial Tree is about 6.97 USD, higher than 6.73 USD of European Put Option.


# Question 4

## Question 4.1
## \textcolor{red}{Solution:}

We have that 30% of initial wealth of 10 million USD invested in Yuan, so the value of wealth invested in Yuan is 3 million USD. At t=0, each USD is worth 6.1 Yuan, so the number of shares of Yuan invested is: 3,000,000*6.1 = 18,300,000 units

## Question 4.2
## \textcolor{red}{Solution:}
We can find the number of time steps for simulation as: (10/252)/0.001 = 40
```{r}
N4 = 300000 # Number of simulations
M4 = 40 # Number of Time Steps
x0 = 80 # Initial X price
y0 = 90000 # Initial Y price
z0 = 6.1 # Initial Z price
t4 = 10/252 # Time
delt = 0.001 # Delta t
vt = seq(0.001, 0.04, 0.001) # Time discretized
sd = sqrt(delt) # sigma of Brownian Motion
wx = 0.4 # Initial Weight of X
wy = 0.3 # Initial Weight of Y
wz = 0.3 # Initial Weight of Z
```
For this problem, I use 300,000 simulations, rather than 3 million since it would require lots of time

Assume that the number of shares of each asset is kept the same for the entire 10 days.
```{r}
# Number of shares of each asset at the beginning
sx = 10000000*wx/x0
sy = 10000000*wy/y0
sz = 10000000*wz*z0

# Monte Carlo simulation for process of asset
x.mat <- matrix(nrow = N4, ncol = M4)
y.mat <- matrix(nrow = N4, ncol = M4)
z.mat <- matrix(nrow = N4, ncol = M4)
for(i in 1:N4) {
  for(j in 2:M4) {
    set.seed(i)
    x.mat[i, 1] = x0 + 0.01*x0*delt + 0.3*x0*rnorm(1,0,sd)
    set.seed(i)
    y.mat[i, 1] = y0 + 100*(90000 + 100*vt[1] - y0) + sqrt(y0)*rnorm(1,0,sd)
    set.seed(i)
    z.mat[i, 1] = z0 + 5*(6 - z0)*delt + 0.01*sqrt(z0)*rnorm(1,0,sd)
    set.seed(i*j*2)
    x.mat[i, j] = x.mat[i, j-1] + 0.01*x.mat[i, j-1]*delt + 0.3*x.mat[i, j-1]*rnorm(1,0,sd)
    set.seed(i*j*3)
    y.mat[i, j] = y.mat[i, j-1] + 100*(90000 + 1000*vt[j] - y.mat[i, j-1])*delt + 
      sqrt(y.mat[i, j-1])*rnorm(1,0,sd)
    set.seed(i*j*4)
    z.mat[i, j] = z.mat[i, j-1] + 5*(6 - z.mat[i, j-1])*delt + 
      0.01*sqrt(z.mat[i, j-1])*rnorm(1,0,sd)
  }
}

# Possible values of each asset in the portfolio at the end of the 10th day
fin.val.x.mat <- c()
fin.val.y.mat <- c()
fin.val.z.mat <- c()
for(i in 1:N4) {
  fin.val.x.mat[i] = x.mat[i, M4]*sx
  fin.val.y.mat[i] = y.mat[i, M4]*sy
  fin.val.z.mat[i] = sz/z.mat[i, M4]
}

# Possible values of the portfolio at the end of the 10th day
fin.port.sim <- c()
for(i in 1:N4) {
  fin.port.sim[i] = fin.val.x.mat[i] + fin.val.y.mat[i] + fin.val.z.mat[i]
}

# Possible return of the portfolio, using simple return calculation
sim.ret.port <- c()
for(i in 1:N4) {
  sim.ret.port[i] = fin.port.sim[i]/10000000 - 1
}

# Value at risk of the portfolio over 10 days at the 95th percentile
library(PerformanceAnalytics)
VaR(sim.ret.port, 0.95)

# Conditional Value at Risk at the confidence level of 95th percentile
ES(sim.ret.port, 0.95)
```
So for 10 days, at the 95th confidence level, the Value at Risk of the portfolio is about 3.7% of its inital values. And the conditional value at risk of portfolio over 10 days is about 4.59%

